/// @title ERC20
/// @author Yashiru <https://github.com/Yashiru>
/// @notice ERC20 token contract

/* Imports */
#include "../../access/Ownable.huff"
#include "../../utils/Address.huff"
#include "../../utils/Map.huff"

/* Interface */
#define function mint(address,uint256) nonpayable returns ()

#define function transfer(address,uint256) nonpayable returns ()
#define function transferFrom(address,address,uint256) nonpayable returns ()
#define function approve(address,uint256) nonpayable returns ()

#define function balanceOf(address) view returns (uint256)
#define function allowance(address,address) view returns (uint256)
#define function totalSupply() view returns (uint256)

#define function owner() view returns (address)

#define event Transfer(address,address,uint256)
#define event Approve(address,address,uint256)

/* Events Signatures */
#define constant TRANSFER_EVENT_SIGNATURE = 0xDDF252AD1BE2C89B69C2B068FC378DAA952BA7F163C4A11628F55A4DF523B3EF
#define constant APPROVAL_EVENT_SIGNATURE = 0x8C5BE1E5EBEC7D5BD14F71427D1E84F3DD0314C0F7B2291E5B200AC8C7C3B925

/* Storage Slots */
#define constant BALANCE_LOCATION = FREE_STORAGE_POINTER()
#define constant ALLOWANCE_LOCATION = FREE_STORAGE_POINTER()
#define constant TOTAL_SUPPLY_LOCATION = FREE_STORAGE_POINTER()

/* Constructor */
#define macro CONSTRUCTOR() = takes(0) returns (0) {
    // Set msg.sender as the owner of the contract.
    OWNABLE_CONSTRUCTOR()
}

/// @dev Get the balance of an account
///
///      Expected calldata: `address` containing the address of the
///      targeted account.
#define macro BALANCE_OF() = takes (0) returns (0) {
    // Load the address in stack
    0x04 calldataload                               // [address]
    // Load the balance of the account
    [BALANCE_LOCATION] LOAD_ELEMENT_FROM_KEYS(0x00) // [balance]
    // Store the balance in memory
    0x00 mstore                                     // []
    // Return the first 32 bytes of the memory
    0x20 0x00 return                                // []
}

/// @dev Get the total supply
#define macro TOTAL_SUPPLY() = takes (0) returns (0) {
    // Load the total supply
    [TOTAL_SUPPLY_LOCATION] sload   // [supply]
    // Store total supply in memory
    0x00 mstore                     // []
    // Return the first 32 bytes of memory
    0x20 0x00 return                // []
}

/// @dev Get the allowance of an owner towards a spender.
///
///      Expected calldata: `address, address` with the owner first
///      and the spender in second
#define macro ALLOWANCE() = takes (0) returns (0) {
    // Load the calldata's bytes from 36 to 68
    0x24 calldataload               // [to]
    // Load the calldata's bytes from 4 to 36
    0x04 calldataload               // [from, to]
    // Load the allowance of the owner towads the spender
    LOAD_ELEMENT_FROM_KEYS(0x00)    // [value]
    
    // Store the allowance in memory 
    0x00 mstore
    // Return the first 32 bytes of memory
    0x20 0x00 return
}


/// @dev Decrease balance of an account according to 
///      the parent Transfer action.
///      Simply decrease the balance of the `from`.
#define macro TRANSFER_TAKE_FROM(error) = takes(3) returns (3) {
    // Ensure that the sender has a sufficient balance.
    // input stack: [value, from, to]
    dup2                // [from, value, from, to]
    [BALANCE_LOCATION] LOAD_ELEMENT_FROM_KEYS(0x00)  // [balance, value, from, to]
    dup1                // [balance, balance, value, from, to]
    dup3                // [value, balance, balance, value, from, to]
    gt 0x0 eq           // [value>balance, balance, value, from, to]              
    0x20                // [msg length, value>balance, balance, value, from, to]              
    0x45524332303a20616d6f756e7420657863656564732062616c616e6365000000
    swap2               // [value>balance, require msg.len, msg, balance, value, from, to]
    REQUIRE()  

    // Update the sender's balance.
    // input stack: [balance, value, from, to]
    dup2                // [value, balance, value, from, to]
    swap1               // [balance, value, value, from, to]
    sub                 // [balance - value, value, from, to]
    dup3                // [from, balance-value, value, from, to]
    [BALANCE_LOCATION] STORE_ELEMENT_FROM_KEYS(0x00) // [value, from, to]
}

/// @dev Increase balance of an account according to 
///      the parent Transfer action.
///      Simply increase the balance of the `to`.
#define macro TRANSFER_GIVE_TO() = takes(3) returns (0) {
    // Update the balance of the recipient.
    // input stack: [value, from, to]
    dup3                // [to, value, from, to]
    dup2                // [value, to, value, from, to]
    swap1               // [to, value, value, from, to]
    [BALANCE_LOCATION] LOAD_ELEMENT_FROM_KEYS(0x00)  // [balance, value, value, from, to]
    add                 // [balance+value, value, from, to]
    dup4                // [to, balance+value, value, from, to]
    [BALANCE_LOCATION] STORE_ELEMENT_FROM_KEYS(0x00) // [value, from, to]
}

/// @dev Set the allowance of an owner towards a spender.
///
///      Expected calldata: `address, uint256` with the spender first
///      and the amount in second
#define macro APPROVE() = takes (0) returns (0) {
    // Load the calldata's bytes from 36 to 68
    0x24 calldataload       // [value]
    // Load the calldata's bytes from 4 to 36
    0x04 calldataload       // [to, value]
    // Load the caller addres
    caller                  // [from, to, value]

    // Store the new allowance of the caller towards the spender
    STORE_ELEMENT_FROM_KEYS(0x00) 
}

/// @dev ERC20 transfer from caller to an account
///
///      Expected calldata: `address, uint256` with the recipient first
///      and the amount in second
#define macro TRANSFER() = takes(0) returns(1) {
    // Setup the stack for the transfer function.
    0x04 calldataload   // [to]
    caller              // [from, to]
    0x24 calldataload   // [value, from, to]

    // Update the balances of the sender and recipient.
    TRANSFER_TAKE_FROM()   // [value, from, to]
    TRANSFER_GIVE_TO()          // [value, from, to]

    // Emit the transfer event.
    0x00 mstore                 // [from, to]
    [TRANSFER_EVENT_SIGNATURE]  // [sig, from, to]
    0x20 0x00                   // [0, 32, sig, from, to]
    log3                        // []

    // Return "1" to represent a succesful transfer.
    0x01 0x00 mstore
    0x20 0x00 return
}

/// @dev ERC20 transferFrom from and account to an other
///
///      Expected calldata: `address, uint256` with the recipient first
///      and the amount in second
#define macro TRANSFER_FROM() = takes(0) returns(1) {
    // Setup the stack for the transfer function.
    0x24 calldataload                           // [to]
    0x04 calldataload dup1                      // [from, from, to]
    caller swap1                                // [from, caller, from, to]
    LOAD_ELEMENT_FROM_KEYS(0x00)                // [allowance, from, to]
    0x44 calldataload dup1                      // [value, value, allowance, from, to]
    dup3 dup2 lt swap3 eq swap1 swap2 or        // [value >= allowance, value, from, to]
    0x1D                                        // [0x1D, value >= allowance, value, from, to]            
    0x45524332303a20696e73756666696369656e7420616c6c6f77616e6365
    swap2                                       // [value < allowance || allowance == value, msg length, msg, value, from, to] 
    REQUIRE()

    // Update the balances of the sender and recipient.
    TRANSFER_TAKE_FROM()        // [value, from, to]
    TRANSFER_GIVE_TO()          // [value, from, to]

    // Emit the transfer event.
    0x00 mstore                 // [from, to]
    [TRANSFER_EVENT_SIGNATURE]  // [sig, from, to]
    0x20 0x00                   // [0, 32, sig, from, to]
    log3                        // []

    // Return "1" to represent a succesful transfer.
    0x01 0x00 mstore
    0x20 0x00 return
}

/// @dev Mint token to an account
///
///      Expected calldata: `address, uint256` with the account address first
///      and the amount to mint in second
#define macro MINT() = takes(0) returns (0) {
    // Ensure that the sender is the owner of the contract.
    ONLY_OWNER()

    // Setup the stack for the mint function.
    0x04 calldataload   // [to]
    0x00                // [from (0x00), to]
    0x24 calldataload   // [value, from, to]

    // Give tokens to the recipient.
    TRANSFER_GIVE_TO()  // [value, from, to]

    // Update totalSupply
    dup1                            // [value, value, from, to]
    [TOTAL_SUPPLY_LOCATION] sload    // [supply,value,value,from,to]
    add                             // [supply+value,value,from,to]
    [TOTAL_SUPPLY_LOCATION] sstore  // [value,from,to]


    // Emit the transfer event.
    0x00 mstore                 // [from, to]
    [TRANSFER_EVENT_SIGNATURE]  // [sig, from, to]
    0x20 0x00                   // [0, 32, sig, from, to]
    log3                        // []
}

// Main Macro
#define macro MAIN() = takes(0) returns (0) {
    // Identify which function is being called.
    0x00 calldataload 0xE0 shr

    /* ERC20 JumpDest */
    dup1 __FUNC_SIG(transfer) eq transfer jumpi
    dup1 __FUNC_SIG(transferFrom) eq transferFrom jumpi
    dup1 __FUNC_SIG(mint) eq mints jumpi
    dup1 __FUNC_SIG(balanceOf) eq balanceOf jumpi
    dup1 __FUNC_SIG(totalSupply) eq totalSupply jumpi
    dup1 __FUNC_SIG(approve) eq approve jumpi
    dup1 __FUNC_SIG(allowance) eq allowance jumpi
    /* Ownable JumpDest */
    __FUNC_SIG(owner) eq owner jumpi

    /* ERC20 JumpDest */
    transfer:
        TRANSFER()
    transferFrom:
        TRANSFER_FROM()
    mints:
        MINT()
    balanceOf:
        BALANCE_OF()
    totalSupply:
        TOTAL_SUPPLY()
    approve:
        APPROVE()
    allowance:
        ALLOWANCE()

    /* Ownable JumpDest */
    owner:
        OWNER()
}